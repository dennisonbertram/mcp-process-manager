# Error Tracking Tools

## Overview
Implementation of comprehensive error tracking and analysis tools for capturing, categorizing, and managing process errors with historical analysis capabilities.

## Error Manager Implementation

### Error Manager Service
```typescript
// src/errors/manager.ts
import { DatabaseManager } from '../database/manager.js';
import winston from 'winston';
import { ErrorEntry } from '../types/process.js';
import { EventEmitter } from 'events';

export interface ErrorFilter {
  processId?: string;
  errorType?: string;
  resolved?: boolean;
  startTime?: number;
  endTime?: number;
  limit?: number;
  offset?: number;
}

export interface ErrorSummary {
  totalErrors: number;
  unresolvedErrors: number;
  errorsByType: Record<string, number>;
  errorsByProcess: Record<string, number>;
  mostRecentError?: ErrorEntry;
  errorRate: number; // Errors per hour
}

export class ErrorManager extends EventEmitter {
  private database: DatabaseManager;
  private logger: winston.Logger;
  private errorPatterns: Map<string, RegExp>;

  constructor(database: DatabaseManager, logger: winston.Logger) {
    super();
    this.database = database;
    this.logger = logger;
    this.errorPatterns = this.initializeErrorPatterns();
  }

  private initializeErrorPatterns(): Map<string, RegExp> {
    const patterns = new Map<string, RegExp>();

    // Common error patterns for categorization
    patterns.set('OutOfMemory', /ENOMEM|out of memory|heap out of memory/i);
    patterns.set('PermissionDenied', /EACCES|permission denied|access denied/i);
    patterns.set('FileNotFound', /ENOENT|no such file|file not found/i);
    patterns.set('ConnectionError', /ECONNREFUSED|ETIMEDOUT|connection refused|timeout/i);
    patterns.set('SyntaxError', /SyntaxError|unexpected token|parsing error/i);
    patterns.set('TypeError', /TypeError|undefined is not|cannot read property/i);
    patterns.set('NetworkError', /EHOSTUNREACH|ENETUNREACH|network unreachable/i);
    patterns.set('DiskSpace', /ENOSPC|no space left|disk full/i);

    return patterns;
  }

  private categorizeError(message: string, stack?: string): string {
    const fullText = `${message} ${stack || ''}`;

    for (const [category, pattern] of this.errorPatterns.entries()) {
      if (pattern.test(fullText)) {
        return category;
      }
    }

    // Default categorization based on error class
    if (message.includes('Error:')) {
      const errorType = message.split(':')[0].trim();
      return errorType;
    }

    return 'UnknownError';
  }

  async recordError(
    processId: string,
    error: Error | string,
    additionalContext?: Record<string, any>
  ): Promise<void> {
    const errorMessage = typeof error === 'string' ? error : error.message;
    const errorStack = typeof error === 'object' ? error.stack : undefined;
    const errorType = this.categorizeError(errorMessage, errorStack);

    const errorEntry: ErrorEntry = {
      processId,
      errorType,
      message: errorMessage,
      stackTrace: errorStack,
      timestamp: Date.now(),
      resolved: false
    };

    // Store in database
    this.database.getStatement('insertError').run({
      process_id: errorEntry.processId,
      error_type: errorEntry.errorType,
      message: errorEntry.message,
      stack_trace: errorEntry.stackTrace,
      timestamp: errorEntry.timestamp
    });

    // Log the error
    this.logger.error(`Process ${processId} error:`, {
      type: errorType,
      message: errorMessage,
      context: additionalContext
    });

    // Emit event for real-time monitoring
    this.emit('newError', errorEntry);

    // Check if this is a critical error that needs immediate attention
    if (this.isCriticalError(errorType)) {
      this.emit('criticalError', errorEntry);
    }
  }

  private isCriticalError(errorType: string): boolean {
    const criticalTypes = ['OutOfMemory', 'DiskSpace', 'PermissionDenied'];
    return criticalTypes.includes(errorType);
  }

  async getErrors(filter: ErrorFilter): Promise<ErrorEntry[]> {
    let query = 'SELECT * FROM errors WHERE 1=1';
    const params: any[] = [];

    if (filter.processId) {
      query += ' AND process_id = ?';
      params.push(filter.processId);
    }

    if (filter.errorType) {
      query += ' AND error_type = ?';
      params.push(filter.errorType);
    }

    if (filter.resolved !== undefined) {
      query += ' AND resolved = ?';
      params.push(filter.resolved ? 1 : 0);
    }

    if (filter.startTime) {
      query += ' AND timestamp >= ?';
      params.push(filter.startTime);
    }

    if (filter.endTime) {
      query += ' AND timestamp <= ?';
      params.push(filter.endTime);
    }

    query += ' ORDER BY timestamp DESC';

    if (filter.limit) {
      query += ' LIMIT ?';
      params.push(filter.limit);

      if (filter.offset) {
        query += ' OFFSET ?';
        params.push(filter.offset);
      }
    }

    const stmt = this.database.getDb().prepare(query);
    const results = stmt.all(...params);

    return results.map(row => ({
      id: row.id,
      processId: row.process_id,
      errorType: row.error_type,
      message: row.message,
      stackTrace: row.stack_trace,
      timestamp: row.timestamp,
      resolved: Boolean(row.resolved)
    }));
  }

  async getLatestErrors(
    limit: number = 10,
    unresolvedOnly: boolean = true
  ): Promise<ErrorEntry[]> {
    const filter: ErrorFilter = {
      limit,
      resolved: unresolvedOnly ? false : undefined
    };

    return this.getErrors(filter);
  }

  async markErrorResolved(errorId: number, resolution?: string): Promise<void> {
    const stmt = this.database.getDb().prepare(
      'UPDATE errors SET resolved = 1 WHERE id = ?'
    );
    const result = stmt.run(errorId);

    if (result.changes > 0) {
      this.logger.info(`Marked error ${errorId} as resolved${resolution ? `: ${resolution}` : ''}`);
      this.emit('errorResolved', { errorId, resolution });
    } else {
      throw new Error(`Error ${errorId} not found`);
    }
  }

  async getErrorSummary(
    processId?: string,
    timeWindow?: number // milliseconds
  ): Promise<ErrorSummary> {
    const startTime = timeWindow ? Date.now() - timeWindow : 0;
    const whereClause = [];
    const params: any[] = [];

    if (processId) {
      whereClause.push('process_id = ?');
      params.push(processId);
    }

    if (startTime > 0) {
      whereClause.push('timestamp >= ?');
      params.push(startTime);
    }

    const where = whereClause.length > 0 ? `WHERE ${whereClause.join(' AND ')}` : '';

    // Get total and unresolved counts
    const countStmt = this.database.getDb().prepare(`
      SELECT
        COUNT(*) as total,
        SUM(CASE WHEN resolved = 0 THEN 1 ELSE 0 END) as unresolved
      FROM errors ${where}
    `);
    const counts = countStmt.get(...params) as { total: number; unresolved: number };

    // Get errors by type
    const typeStmt = this.database.getDb().prepare(`
      SELECT error_type, COUNT(*) as count
      FROM errors ${where}
      GROUP BY error_type
      ORDER BY count DESC
    `);
    const typeResults = typeStmt.all(...params) as Array<{ error_type: string; count: number }>;
    const errorsByType = typeResults.reduce((acc, row) => {
      acc[row.error_type] = row.count;
      return acc;
    }, {} as Record<string, number>);

    // Get errors by process
    const processStmt = this.database.getDb().prepare(`
      SELECT process_id, COUNT(*) as count
      FROM errors ${where}
      GROUP BY process_id
      ORDER BY count DESC
    `);
    const processResults = processStmt.all(...params) as Array<{ process_id: string; count: number }>;
    const errorsByProcess = processResults.reduce((acc, row) => {
      acc[row.process_id] = row.count;
      return acc;
    }, {} as Record<string, number>);

    // Get most recent error
    const recentErrors = await this.getLatestErrors(1, false);
    const mostRecentError = recentErrors[0];

    // Calculate error rate (errors per hour)
    const timeRange = timeWindow || (Date.now() - (mostRecentError?.timestamp || Date.now()));
    const hoursElapsed = Math.max(timeRange / (1000 * 60 * 60), 1);
    const errorRate = counts.total / hoursElapsed;

    return {
      totalErrors: counts.total,
      unresolvedErrors: counts.unresolved || 0,
      errorsByType,
      errorsByProcess,
      mostRecentError,
      errorRate
    };
  }

  async getErrorTrends(
    processId?: string,
    bucketSizeMs: number = 3600000, // 1 hour buckets by default
    limit: number = 24
  ): Promise<Array<{ timestamp: number; count: number; types: Record<string, number> }>> {
    const now = Date.now();
    const startTime = now - (bucketSizeMs * limit);

    let query = `
      SELECT
        (timestamp / ?) * ? as bucket,
        COUNT(*) as count,
        error_type
      FROM errors
      WHERE timestamp >= ?
    `;
    const params = [bucketSizeMs, bucketSizeMs, startTime];

    if (processId) {
      query += ' AND process_id = ?';
      params.push(processId);
    }

    query += ' GROUP BY bucket, error_type ORDER BY bucket DESC';

    const stmt = this.database.getDb().prepare(query);
    const results = stmt.all(...params) as Array<{
      bucket: number;
      count: number;
      error_type: string;
    }>;

    // Group by bucket
    const buckets = new Map<number, { count: number; types: Record<string, number> }>();

    for (const row of results) {
      if (!buckets.has(row.bucket)) {
        buckets.set(row.bucket, { count: 0, types: {} });
      }

      const bucket = buckets.get(row.bucket)!;
      bucket.count += row.count;
      bucket.types[row.error_type] = (bucket.types[row.error_type] || 0) + row.count;
    }

    return Array.from(buckets.entries())
      .map(([timestamp, data]) => ({ timestamp, ...data }))
      .sort((a, b) => b.timestamp - a.timestamp);
  }

  async getSimilarErrors(
    errorId: number,
    limit: number = 10
  ): Promise<ErrorEntry[]> {
    // Get the original error
    const originalStmt = this.database.getDb().prepare(
      'SELECT * FROM errors WHERE id = ?'
    );
    const original = originalStmt.get(errorId);

    if (!original) {
      throw new Error(`Error ${errorId} not found`);
    }

    // Find similar errors based on type and message similarity
    const stmt = this.database.getDb().prepare(`
      SELECT * FROM errors
      WHERE id != ?
        AND error_type = ?
        AND process_id = ?
      ORDER BY ABS(timestamp - ?) ASC
      LIMIT ?
    `);

    const results = stmt.all(
      errorId,
      original.error_type,
      original.process_id,
      original.timestamp,
      limit
    );

    return results.map(row => ({
      id: row.id,
      processId: row.process_id,
      errorType: row.error_type,
      message: row.message,
      stackTrace: row.stack_trace,
      timestamp: row.timestamp,
      resolved: Boolean(row.resolved)
    }));
  }
}
```

## Tool Implementations

### Error Tools Registration
```typescript
// src/tools/errors.ts
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { z } from 'zod';
import { ErrorManager } from '../errors/manager.js';
import winston from 'winston';

// Schema definitions
const GetErrorsSchema = z.object({
  processId: z.string().optional(),
  errorType: z.string().optional(),
  resolved: z.boolean().optional(),
  startTime: z.number().optional(),
  endTime: z.number().optional(),
  limit: z.number().min(1).max(1000).default(100),
  offset: z.number().min(0).default(0)
});

const GetLatestErrorsSchema = z.object({
  limit: z.number().min(1).max(100).default(10),
  unresolvedOnly: z.boolean().default(true)
});

const MarkErrorResolvedSchema = z.object({
  errorId: z.number().min(1),
  resolution: z.string().optional()
});

export function registerErrorTools(
  server: Server,
  errorManager: ErrorManager,
  logger: winston.Logger
): void {
  // Tool: get_errors
  server.setRequestHandler({
    method: 'tools/call',
    handler: async (request) => {
      if (request.params.name === 'get_errors') {
        try {
          const args = GetErrorsSchema.parse(request.params.arguments || {});
          const errors = await errorManager.getErrors(args);

          const summary = await errorManager.getErrorSummary(
            args.processId,
            args.startTime ? Date.now() - args.startTime : undefined
          );

          const formatted = errors.slice(0, 5).map(err =>
            `[${new Date(err.timestamp).toISOString()}] ${err.errorType}: ${err.message}${err.resolved ? ' (resolved)' : ''}`
          ).join('\n');

          return {
            content: [
              {
                type: 'text',
                text: `Found ${errors.length} errors (${summary.unresolvedErrors} unresolved)\n\nRecent errors:\n${formatted}${errors.length > 5 ? `\n... and ${errors.length - 5} more` : ''}\n\nError rate: ${summary.errorRate.toFixed(2)} errors/hour`
              }
            ],
            data: { errors, summary }
          };
        } catch (error) {
          logger.error('Failed to get errors:', error);
          return {
            content: [
              {
                type: 'text',
                text: `Failed to get errors: ${error.message}`
              }
            ],
            isError: true
          };
        }
      }

      // Tool: get_latest_errors
      if (request.params.name === 'get_latest_errors') {
        try {
          const args = GetLatestErrorsSchema.parse(request.params.arguments || {});
          const errors = await errorManager.getLatestErrors(args.limit, args.unresolvedOnly);

          const formatted = errors.map(err =>
            `[${new Date(err.timestamp).toISOString()}] ${err.processId} - ${err.errorType}: ${err.message}`
          ).join('\n');

          return {
            content: [
              {
                type: 'text',
                text: `Latest ${args.unresolvedOnly ? 'unresolved ' : ''}errors (${errors.length}):\n\n${formatted || 'No errors found'}`
              }
            ],
            data: errors
          };
        } catch (error) {
          logger.error('Failed to get latest errors:', error);
          return {
            content: [
              {
                type: 'text',
                text: `Failed to get latest errors: ${error.message}`
              }
            ],
            isError: true
          };
        }
      }

      // Tool: mark_error_resolved
      if (request.params.name === 'mark_error_resolved') {
        try {
          const args = MarkErrorResolvedSchema.parse(request.params.arguments);
          await errorManager.markErrorResolved(args.errorId, args.resolution);

          return {
            content: [
              {
                type: 'text',
                text: `Marked error ${args.errorId} as resolved${args.resolution ? `: ${args.resolution}` : ''}`
              }
            ]
          };
        } catch (error) {
          logger.error('Failed to mark error resolved:', error);
          return {
            content: [
              {
                type: 'text',
                text: `Failed to mark error resolved: ${error.message}`
              }
            ],
            isError: true
          };
        }
      }
    }
  });

  // Register tool definitions
  server.setRequestHandler({
    method: 'tools/list',
    handler: async () => {
      return {
        tools: [
          {
            name: 'get_errors',
            description: 'Retrieve error history with filtering options',
            inputSchema: GetErrorsSchema
          },
          {
            name: 'get_latest_errors',
            description: 'Get recent errors across all processes',
            inputSchema: GetLatestErrorsSchema
          },
          {
            name: 'mark_error_resolved',
            description: 'Mark an error as resolved with optional resolution notes',
            inputSchema: MarkErrorResolvedSchema
          }
        ]
      };
    }
  });
}
```

## Testing Strategy

### Phase 1: Error Categorization Testing
```bash
# Test error pattern matching
node -e "
  const patterns = new Map();
  patterns.set('OutOfMemory', /ENOMEM|out of memory/i);
  patterns.set('ConnectionError', /ECONNREFUSED|timeout/i);

  const errors = [
    'Error: ENOMEM: Cannot allocate memory',
    'Error: ECONNREFUSED: Connection refused',
    'TypeError: Cannot read property of undefined'
  ];

  errors.forEach(err => {
    let category = 'Unknown';
    for (const [cat, pattern] of patterns.entries()) {
      if (pattern.test(err)) {
        category = cat;
        break;
      }
    }
    console.log(err, '->', category);
  });
"
```

### Phase 2: MCP Tool Testing
```bash
# Get errors
echo '{"jsonrpc":"2.0","method":"tools/call","params":{"name":"get_errors","arguments":{"unresolvedOnly":true}},"id":1}' | node dist/index.js

# Get latest errors
echo '{"jsonrpc":"2.0","method":"tools/call","params":{"name":"get_latest_errors","arguments":{"limit":5}},"id":2}' | node dist/index.js

# Mark error resolved
echo '{"jsonrpc":"2.0","method":"tools/call","params":{"name":"mark_error_resolved","arguments":{"errorId":1,"resolution":"Fixed memory leak"}},"id":3}' | node dist/index.js
```

### Phase 3: Integration Testing
```typescript
// tests/errors.test.ts
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { ErrorManager } from '../src/errors/manager';
import { DatabaseManager } from '../src/database/manager';
import winston from 'winston';

describe('Error Tracking Tools', () => {
  let errorManager: ErrorManager;
  let db: DatabaseManager;

  beforeEach(() => {
    const logger = winston.createLogger({ silent: true });
    db = new DatabaseManager(':memory:', logger);
    errorManager = new ErrorManager(db, logger);
  });

  afterEach(() => {
    db.close();
  });

  it('should categorize errors correctly', async () => {
    await errorManager.recordError('test-1', new Error('ENOMEM: out of memory'));
    const errors = await errorManager.getErrors({ processId: 'test-1' });

    expect(errors[0].errorType).toBe('OutOfMemory');
  });

  it('should track error resolution', async () => {
    await errorManager.recordError('test-1', new Error('Test error'));
    const errors = await errorManager.getErrors({ processId: 'test-1' });

    await errorManager.markErrorResolved(errors[0].id!, 'Fixed');
    const resolved = await errorManager.getErrors({ resolved: true });

    expect(resolved[0].resolved).toBe(true);
  });

  it('should calculate error summary', async () => {
    await errorManager.recordError('test-1', new Error('Error 1'));
    await errorManager.recordError('test-1', new Error('Error 2'));
    await errorManager.recordError('test-2', new Error('Error 3'));

    const summary = await errorManager.getErrorSummary();

    expect(summary.totalErrors).toBe(3);
    expect(summary.unresolvedErrors).toBe(3);
    expect(Object.keys(summary.errorsByProcess)).toHaveLength(2);
  });
});
```

## Success Criteria

### Implementation Checklist
- [ ] Error categorization with patterns
- [ ] Critical error detection
- [ ] Error recording with stack traces
- [ ] Resolution tracking system
- [ ] Error summary statistics
- [ ] Trend analysis over time
- [ ] Similar error detection
- [ ] All 3 error tools implemented
- [ ] Real-time error events
- [ ] Error rate calculations

### Performance Metrics
- [ ] Error categorization < 1ms
- [ ] Error storage < 10ms
- [ ] Summary calculation < 50ms
- [ ] Trend analysis < 100ms for 10k errors
- [ ] Similar error search < 20ms

## Dependencies
- Requires Task 0001 (Server Setup) complete
- Database must have errors table
- Process manager must emit error events

## Next Steps
After implementing error tools:
1. Add process group management (Task 0006)
2. Create resources and prompts (Task 0007)
3. Implement testing strategy (Task 0008)